%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capítulo 3: Procedimiento experimental
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

En este capítulo se enumerarán los experimentos realizados en la verificación del cálculo de las raíces de la función tratada.

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section{Descripción de los experimentos}
\label{3:sec:1}
En este capítulo se enumerarán los experimentos realizados en la verificación del cálculo de las raíces de la función tratada. Se ha redactado un código en el lenguaje de programación Python con tal objetivo y se ha analizado su funcionamiento. El código cuenta con una función a la que hemos llamado newton que calcula el resultado de aplicar la fórmula de Newton siempre que el valor introducido sea mayor que cero. Esta función evalúa el error cometido como la diferencia entre el valor obtenido y el valor de partida. El proceso se ejecutará tantas veces como sea necesario para que el error sea menor que un valor prefijado. Si el punto de partida es cero o negativo, no se podrá aplicar el método de newton y el programa advertirá al usuario. El programa se ejecutará con los valores que el usuario introduce como parámetro, pero en el caso de que estos se omitan, tomará valores por defecto.
En el apéndice \ref{Apendicenewton} se puede cosultar el código descrito.

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section{Descripción del material}
\label{3:sec:2}
Para la realización de este experimento se ha utilizado un ordenador que cuenta con un un procesador Intel(R) Pentium(R) CPU B960 @ 2.20GHz. El computador cuenta con 400Gb de disco duro y 6Gb de memoria RAM. Así mismo, dispone de una velocidad de CPU de 800.000Hz y un caché de CPU de 2048 KB.

El sistema operativo empleado es una adaptación de la distribución de Linux \textit{kubuntu} a las necesidades en cuanto a Software de los miembros de la comunidad universitaria ULL: Bardinux, en concreto se ha utilizado Linux-3.2.0-37-generic-i686-with-Ubuntu-12.04-precise. Se ha interpretado el código descrito con el intérprete de Python que cuenta este sistema operativo, la versión utilizada ha sido la 2.7.3. 

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Resultados obtenidos}
\label{3:sec:3}

Tras la implementación del código, se ha comprobado su precisión dando valores que serán las aproximaciones iniciales de la raíz y se han obtenido los resultados plasmados en la siguiente tabla.

\input{tables/table.tex}

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Análisis de los resultados}
\label{3:sec:4}

Al ejecutar el programa con distintos valores como aproximación inicial de la raíz se observa que en todos los casos se calcula la raíz situada en el punto x=1 con precisión, y por tanto el valor de la función en ese punto es cero.



\begin{figure}[!th]

\begin{center}

\includegraphics[width=0.75\textwidth]{images/ln-1.eps}

\caption{Ejemplo de figura}

\label{fig:1}

\end{center}

\end{figure} 

Esta figura se ha realizado con mathplotlib. En el apéndice \ref{Apendicelog} se puede consultar el código.

Por otro lado, cabe destacar que el número de veces que se aplica la fórmula del método de newton, es decir, las iteraciones necesarias para obtener los resultados expuestos crecen cuando la aproximación inicial que introducimos se aleja de la raíz. Así, por ejemplo, si introducimos como aproximación inicial la propia raíz, bastaría con una iteración para obtener los resultados buscados.

Si se traza una función que represente el número de iteraciones necesarias para calcular las raíces mediante el método de newton para la función $f(x)= log(x)$, se observa que ésta tiene una mayor pendiente cuando nos aproximamos cero. A medida que nos alejamos, aunque se mantiene creciente, el valor la pendiente será menor. Esto ocurre ya que el método de Newton calcula la raíz de una función utilizando su derivada, que no es más que el valor de la pendiente de la recta tangente en ese punto. Pues bien, como vemos, la pendiente de la recta tangente en el caso de la función $f(x)= log(x)$ es superior a medida que nos acercamos a cero.

El tiempo de CPU aumenta a medida que se incrementa el valor inicial, al alejarse de la raíz y necesitar que se desarrolle el método de Newton un mayor número de veces. Sin embargo, para cualquier valor inicial que se introduzca el tiempo de CPU 
registrado será cero. Así que, para obtener datos al respecto, se ha ejecutado el programa 100000 para cada valor empleando el módulo timeit. En el apéndice \ref{Apendicetime} se puede observar este código.
De este modo, se puede observar por ejemplo que se tarda más tiempo en ejecutar el método partiendo de x = 7.389 que desde x = 2.0 (2 segundos y pico frente a 0.66 segundos).
Los resultados se han almacenado en la siguiente tabla:

\input{tables/table1.tex}

Estos resultados se han representado en la siguiente gráfica:

\begin{figure}[!th]

\begin{center}

\includegraphics[width=0.75\textwidth]{images/time.eps}

\caption{Tiempo de CPU}

\label{fig:2}

\end{center}

\end{figure} 

Esta figura se ha realizado con mathplotlib. En el apéndice \ref{Apendicecpu} se puede consultar el código.

Nótese que se ha introducido como valor máximo al explicar el tiempo de ejecución el valor de 7.389. Esto es debido a que a partir de este valor, las aproximaciones en vez de acercarse al 1.00000 se alejan, por lo que llega un momento en el que el valor de x es tan grande, que se produce una división por cero al evaluar la expresión $\frac{log(x)}{(1/x)}$. Por lo tanto, como x es muy grande el cociente $\frac{1}{x}$ tiende a 0 y la división principal provoca el error.








